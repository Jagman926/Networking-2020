#include <stdio.h>
#include <string.h>
#include <sstream>
#include <iostream>
#include "RakNet/RakPeerInterface.h"
#include "RakNet/MessageIdentifiers.h"
#include "Raknet/BitStream.h"
#include "Raknet/RakNetTypes.h"  // MessageID

// NOTES:
// Command Prompt > ipconfig > IPv4 (gets global IP of computer for server connection)
// peer->systemaddress in peer->send is how we specify a user to send data to 
// if broadcasting, its who NOT to send it to

// default max clients
const unsigned int DEFAULT_MAX_CLIENTS = 10;

// number of maximum clients
unsigned int maxClients = DEFAULT_MAX_CLIENTS;


// number of current users, including host
int currentUsers = 0;

// the server port number
unsigned short serverPort;



enum GameMessages
{
	ID_GAME_MESSAGE_1 = ID_USER_PACKET_ENUM + 1,
	// Custom message identifier for welcoming the player
	ID_GAME_MSG_PLAYER_CONNECTED,
	ID_GAME_MSG_PLAYER_DISCONNECTED,
	ID_CHAT_MSG_BROADCAST,
	ID_CHAT_MSG_REQUEST,
	ID_CHAT_MSG_DELIVERY
};

// Contains information for specific clients
struct User
{

public:

	// Name of the user that is printed
	char userName[512];
	// User's IP
	char localIP[512];
	

	// Functions
	// Default ctor
	User() {};
	// Used for creating new users
	User(char name[], char ip[]) { strcpy(userName, name), strcpy(localIP, ip); };

};

// List containing all users 
User users[DEFAULT_MAX_CLIENTS];

// Custom message packet structure /////////
// Force compiler to pack the structure as byte-aligned.
#pragma pack (push, 1)
struct messagePack
{
public: 
	RakNet::MessageID msgID;
	// Should use pre allocated byte array memory instead of string
	std::string msgString;

	// Functions
	messagePack(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };
	void CreatePacket(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };
	
};
#pragma pack (pop)


/*

Chat message request: Generated by participant, a request for host to send out a message; should have the following fields (at minimum):
Receiver user name: The name of the chat room participant who should receive the message; if the message is public (broadcast), use some recognizable keyword or symbol.  Messaging the host is also allowed; self-messaging is not allowed.
Message text: The contents of the message.  Should have a maximum length.

*/
#pragma pack (push, 1)
struct ChatMessageRequest
{
public:
	

	// The name of the chat room participant who should receive the message
	char recieverUserName[512];
	// The contents of the message.  Should have a maximum length.
	char msgTxt[512];


	// Functions
	// ChatMessageRequest(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };
	// void CreatePacket(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };

};
#pragma pack (pop)

/*

Chat message delivery: Generated by host, an actual message being delivered.  Should have the following fields (at minimum):
Sender user name: The name of the participant from whom the message originated; since this could include the host, they should be a recognizable name.
Public or private: Indicates whether the message was broadcast or directed at the receiver.
Message text: The contents of the message.  Should have a maximum length (same as above).

*/

#pragma pack (push, 1)
struct ChatMessageDelivery
{
public:
	
	// The name of the participant from whom the message originated; since this could include the host, they should be a recognizable name.
	char senderUserName[1024];
	// Indicates whether the message was broadcast or directed at the receiver.
	bool priv;
	// The contents of the message.  Should have a maximum length.
	char msgTxt[1024];

	// Functions
	//ChatMessageDelivery(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };
	//void CreatePacket(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };

};
#pragma pack (pop)

int main(void)
{
	char str[1024];
	// Name of the client 
	char clientName[1024];
	RakNet::RakPeerInterface* peer = RakNet::RakPeerInterface::GetInstance();
	bool isServer;

	// Create our packet variable
	RakNet::Packet *packet;
	// Connected to chat
	bool connected = false;
	
	
	while (1)
	{
		if (!connected)
		{
			// TO-DO: Create exit prompt to close the application
			printf("Welcome to the chat room!\n");
			printf("You are currently in the lobby state.\n");
			printf("Would you like to Join (J) or Host (H) a chat room?\n");
			fgets(str, 512, stdin);

			if ((str[0] == 'j') || (str[0] == 'J'))
			{
				RakNet::SocketDescriptor sd;
				peer->Startup(1, &sd, 1);
				isServer = false;

				//// Prompt for server port input
				//printf("Enter server port number\n");
				//// Read user input
				//fgets(str, 512, stdin);
				//// Set server port to inputed value in str
				//serverPort = strtol(str, NULL, 0);

				// fixed server port
				serverPort = 1;

				// Connected
				connected = true;
			}
			else {

				//// Prompt for client number input; only when using a server
				//printf("Enter maximum client number\n");
				//// Read user input
				//fgets(str, 512, stdin);
				//// Set max clients to inputed value in str
				//maxClients = strtol(str, NULL, 0);

				// fixed server port
				serverPort = 1;

				RakNet::SocketDescriptor sd(serverPort, 0);
				peer->Startup(maxClients, &sd, 1);
				isServer = true;

				// create the server's name which will always be the same so its recognizable
				char adminName [512] = "Admin";
				
				// Create the User representing the server
				User server(adminName, (char*)peer->GetLocalIP(0));

				// Add the server to the user list
				users[currentUsers] = server;

				// increment current users now that we have one
				currentUsers++;

				// Connected
				connected = true;
			}

			if (isServer)
			{
				printf("Starting the server!!!\n");

				std::cout << "Your IP is: " << peer->GetLocalIP(0) << "\n";

				std::cout << "Your GUID is: " << peer->GetMyGUID().ToString() << "\n";

				// We need to let the server accept incoming connections from the clients
				peer->SetMaximumIncomingConnections(maxClients);


			}
			else
			{
				printf("Enter server IP or hit enter for 127.0.0.1\n");
				fgets(str, 512, stdin);

				// Changed == to 10 since fgets prints enter as 10 instead of 0
				if (str[0] == 10) {
					strcpy(str, "127.0.0.1");
				}
				printf("Starting the client.\n");

				std::cout << "Your IP is: " << peer->GetLocalIP(0) << "\n";

				std::cout << "Your GUID is: " << peer->GetMyGUID().ToString() << "\n";

				peer->Connect(str, serverPort, 0, 0);
			}
		}
		else
		{
			for (packet = peer->Receive(); packet; peer->DeallocatePacket(packet), packet = peer->Receive())
			{
				switch (packet->data[0])
				{
				case ID_REMOTE_DISCONNECTION_NOTIFICATION:
					printf("Another client has disconnected.\n");
					break;
				case ID_REMOTE_CONNECTION_LOST:
					printf("Another client has lost the connection.\n");
					break;
				case ID_REMOTE_NEW_INCOMING_CONNECTION:
					printf("Another client has connected.\n");
					break;
				case ID_CONNECTION_REQUEST_ACCEPTED:
				{
					printf("Our connection request has been accepted.\n");

					// Prompt for player's name
					printf("Type your name: ");
					// Read their input and store it
					fgets(clientName, 512, stdin);

					

					// Create data structure and initialize with our message identifier and message, in this case the user inputted client name
					messagePack pack(ID_GAME_MSG_PLAYER_CONNECTED, clientName);
					// Send the data structure to the server by casting it to a byte stream using const char* and passing the size of our data structure
					peer->Send((const char*)&pack, sizeof(pack), HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress, false);

				

					// Prompt for disconnect message (it doesn't actually disconnect yet, just sends a goodbye message)
					printf("Disconnect? Y/N: ");
					// Get input
					fgets(str, 512, stdin);
					// if yes,
					if ((str[0] == 'y') || (str[0] == 'Y'))
					{
						// Create data structure and initialize with our message identifier and message, in this case the user inputted client name
						messagePack pack(ID_GAME_MSG_PLAYER_DISCONNECTED, clientName);
						// Send the data structure to the server by casting it to a byte stream using const char* and passing the size of our data structure
						peer->Send((const char*)&pack, sizeof(pack), HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress, false);
						// Set to disconnect from server after loop is finished
						connected = false;
					}
				}
				break;
				case ID_NEW_INCOMING_CONNECTION:
					printf("A connection is incoming.\n");
					break;
				case ID_NO_FREE_INCOMING_CONNECTIONS:
					printf("The server is full.\n");
					break;
				case ID_DISCONNECTION_NOTIFICATION:
					if (isServer) {
						printf("A client has disconnected.\n");
					}
					else {
						printf("We have been disconnected.\n");
					}
					break;
				case ID_CONNECTION_LOST:
					if (isServer) {
						printf("A client lost the connection.\n");
					}
					else {
						printf("Connection lost.\n");
					}
					break;

				case ID_GAME_MESSAGE_1:
				{
					RakNet::RakString rs;
					RakNet::BitStream bsIn(packet->data, packet->length, false);
					bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
					bsIn.Read(rs);
					printf("%s\n", rs.C_String());
				}
				break;

				// Custom message loop for player welcome
				case ID_GAME_MSG_PLAYER_CONNECTED:
				{

					// Cast packet to our data structure
					messagePack* p = (messagePack*)packet->data;
					
					//char address[512];
					//strcpy(address, packet->systemAddress.GetIPVersion);
					//// Create the client
					//User client(p->msgString.c_str, );
					//
					//
					//// Add the client to the user list
					//users[currentUsers] = client;
					//
					//// increment current users
					//currentUsers++;

					// Print the message with the message string from the structure
					// TODO: Format to fix newline after name
					printf(p->msgString.c_str());
					printf(" has joined the chat!");
					printf("\n");
					printf("Current Users: ");

					for (int i = 0; i < currentUsers; i++)
					{
						printf(users[i].userName);
						printf(users[i].localIP);
						printf("\n");

					}
		

					//TODO - Fix string stream
					// Broadcast to other clients a user has connected to 
					std::string broadcastMsg;
					
					broadcastMsg = packet->guid.ToString();
					
					messagePack pack(ID_CHAT_MSG_BROADCAST, broadcastMsg.c_str());
					peer->Send((const char*)& pack, sizeof(pack), HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress, true);
				}
				break;

				// Custom message loop for player disconnect
				case ID_GAME_MSG_PLAYER_DISCONNECTED:
				{
					// Cast packet to our data structure
					messagePack* p = (messagePack*)packet->data;
					// Print the message with the message string from the structure
					printf("Goodbye, %s\n", p->msgString.c_str());

				}
				break;

				
				case ID_CHAT_MSG_BROADCAST:
				{
					// Cast packet to our data structure
					messagePack* p = (messagePack*)packet->data;
					// Print the message with the message string from the structure
					printf( p->msgString.c_str());

				}

				
				break;

				default:
					printf("Message with identifier %i has arrived.\n", packet->data[0]);
					break;
				}
			}

			// If set to disconnect, shutdown connection between server
			if(!connected)
				peer->Shutdown(50, 0, LOW_PRIORITY);
		}

	}


	// TODO - Add code body here

	RakNet::RakPeerInterface::DestroyInstance(peer);

	return 0;
}