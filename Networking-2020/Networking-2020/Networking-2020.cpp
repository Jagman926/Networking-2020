#include <stdio.h>
#include <string.h>
#include <sstream>
#include <iostream>
#include "RakNet/RakPeerInterface.h"
#include "RakNet/MessageIdentifiers.h"
#include "Raknet/BitStream.h"
#include "Raknet/RakNetTypes.h"  // MessageID

// NOTES:
// Command Prompt > ipconfig > IPv4 (gets global IP of computer for server connection)
// peer->systemaddress in peer->send is how we specify a user to send data to 
// if broadcasting, its who NOT to send it to

/* MASTER TODO */
/*
	------- MESSAGE STRUCTURE -------
	? User information heading each message
	x Can send and receive public messages (broadcast to all via host) or private messages (to/from a specific participant)

	------- ADMIN STRUCTURE -------
    x Maintains user names and IP addresses of multiple connected users
	? Relays and redirects all messages and events from all participants
	x Broadcast messages to all or selected clients, public or ?private?
	? Displays all inbound and outbound messages, public or private, with the sender and receiver user names
	x On demand, print user names and IP addresses of all connected users to the host console

	------- MESSAGE TYPES -------
	x Chat message request (See type below for tasks)
	x Chat message delivery (See type below for tasks)

	------- USER INTERFACE -------
	x Console clearly displays keyboard commands or shortcuts for user
	- Console should refresh as needed
	? Chat messages should always display the respective sender’s user name
		? If the message was intended for a single user, only they should see it 
		and have some indicator that they are the only one seeing the message, 
		the host being the exception (they can see all messages, public or private)
	x Chat messages should not be re-delivered to the sender
*/

enum GameMessages
{
	ID_GAME_MESSAGE_1 = ID_USER_PACKET_ENUM + 1,
	// Custom message identifier for welcoming the player
	ID_GAME_MSG_PLAYER_CONNECTED,
	ID_GAME_MSG_PLAYER_DISCONNECTED,
	ID_CHAT_MSG_BROADCAST,
	ID_CHAT_MSG_REQUEST,
	ID_CHAT_MSG_DELIVERY
};

// Contains information for specific clients
struct User
{
public:
	/* VARIABLES */

	// Name of the user that is printed
	char userName[512];
	// User's System Address
	std::string systemAddress;
	
	/* FUNCTIONS */

	// Default ctor
	User() {};
	// Used for creating new users
	User(char name[], std::string sysAddress) { strcpy(userName, name), systemAddress = sysAddress; };

};

// Custom message packet structure
// Force compiler to pack the structure as byte-aligned.
#pragma pack (push, 1)
struct messagePack
{
public: 
	/* VARIABLES */

	RakNet::MessageID msgID;
	// Should use pre allocated byte array memory instead of string
	char msgText [512];

	/* FUNCTIONS */

	messagePack(RakNet::MessageID ID, char msg[]) { msgID = ID, strcpy(msgText, msg); };
	//void CreatePacket(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };

};
#pragma pack (pop)

/*
TODO: Chat message request: Generated by participant, a request for host to send out a message. Should have the following fields (at minimum):
	- Receiver user name: The name of the chat room participant who should receive the message
		- if the message is public (broadcast), use some recognizable keyword or symbol
		- Messaging the host is also allowed; self-messaging is not allowed
	- Message text: The contents of the message.  Should have a maximum length
*/

#pragma pack (push, 1)
struct ChatMessageRequest
{
public:

	// leading byte
	RakNet::MessageID msgID;
	// The name of the chat room participant who should receive the message
	char recieverUserName[512];
	// The contents of the message.  Should have a maximum length.
	char msgTxt[512];
	

	// Functions
	ChatMessageRequest(RakNet::MessageID ID, const char name[], const char msg[]) {strcpy(recieverUserName, name), strcpy(msgTxt, msg), msgID = ID;};

};
#pragma pack (pop)

/*
TODO: Chat message delivery: Generated by host, an actual message being delivered. Should have the following fields (at minimum):
	- Sender user name: The name of the participant from whom the message originated
		- Since this could include the host, they should be a recognizable name
	- Public or private: Indicates whether the message was broadcast or directed at the receiver
	- Message text: The contents of the message.  Should have a maximum length (same as above)
*/

#pragma pack (push, 1)
struct ChatMessageDelivery
{
public:
	// leading byte
	RakNet::MessageID msgID;
	// The name of the participant from whom the message originated; since this could include the host, they should be a recognizable name.
	char senderUserName[512];
	// Indicates whether the message was broadcast or directed at the receiver.
	bool priv;
	// The contents of the message.  Should have a maximum length.
	char msgTxt[512];
	
	// Functions
	ChatMessageDelivery(RakNet::MessageID ID, char name[], bool isPrivate, char msg[]) { strcpy(senderUserName, name), priv = isPrivate, strcpy(msgTxt, msg), msgID = ID; };
	//void CreatePacket(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };

};
#pragma pack (pop)

/* VARIABLES */
/* ------------------------------------------------------------------- */

// default max clients
const unsigned int DEFAULT_MAX_CLIENTS = 10;

// number of maximum clients
unsigned int maxClients = DEFAULT_MAX_CLIENTS;

// number of current users, including host
int currentUsers = 0;

// the server port number
unsigned short serverPort;

// List containing all users 
User users[DEFAULT_MAX_CLIENTS];

// string for a message
std::string msg = "";

// string for host system address
std::string hostSystemAddress;



/* ------------------------------------------------------------------- */

int main(void)
{
	// default input string
	char str[1024];

	// Name of the client 
	char clientName[1024];

	// peer instance
	RakNet::RakPeerInterface* peer = RakNet::RakPeerInterface::GetInstance();

	// server booleon
	bool isServer = false;

	// Create our packet variable
	RakNet::Packet *packet;

	// Connected to chat
	bool connected = false;
	
	// While loop to maintain user in application
	while (1)
	{
		if (!connected)
		{
			// TO-DO: Create exit prompt to close the application
			printf("Welcome to the chat room!\n");
			printf("You are currently in the lobby state.\n");
			printf("Would you like to Join (J) or Host (H) a chat room? (D) to Disconnect \n");
			fgets(str, 512, stdin);

			if ((str[0] == 'j') || (str[0] == 'J'))
			{
				RakNet::SocketDescriptor sd;
				peer->Startup(1, &sd, 1);
				isServer = false;

				// fixed server port
				serverPort = 1;

				// Connected
				connected = true;
			}
			else if ((str[0] == 'h') || (str[0] == 'H'))
			{

				// fixed server port
				serverPort = 1;

				RakNet::SocketDescriptor sd(serverPort, 0);
				peer->Startup(maxClients, &sd, 1);
				isServer = true;

				// create the server's name which will always be the same so its recognizable
				char adminName [512] = "Admin";
				
				// Create the User representing the server
				User server(adminName, peer->GetSystemAddressFromGuid(peer->GetMyGUID()).ToString());

				// Add the server to the user list
				users[currentUsers] = server;

				// increment current users now that we have one
				currentUsers++;

				// Connected
				connected = true;
			}
			else 
			{
				// Disconnect
				connected = false;
				break;
			}

			if (isServer)
			{
				printf("Starting the server!!!\n");

				// We need to let the server accept incoming connections from the clients
				peer->SetMaximumIncomingConnections(maxClients);

			}
			else
			{
				printf("Enter server IP or hit enter for 127.0.0.1\n");
				fgets(str, 512, stdin);

				// Changed == to 10 since fgets prints enter as 10 instead of 0
				if (str[0] == 10) {
					strcpy(str, "127.0.0.1");
				}
				printf("Starting the client.\n");

				hostSystemAddress = "184.171.150.100|1";

				peer->Connect(str, serverPort, 0, 0);
			}
		}
		else
		{
			// TODO: Make async key state
			// Get input
			

			for (packet = peer->Receive(); packet; peer->DeallocatePacket(packet), packet = peer->Receive())
			{
				switch (packet->data[0])
				{
					/* ------------------------------------------------------------------------------------------------------- */
					/*                                            DEFAULT MESSAGES                                             */
					/* ------------------------------------------------------------------------------------------------------- */

				case ID_REMOTE_DISCONNECTION_NOTIFICATION:
					printf("Another client has disconnected.\n");
					break;
				case ID_REMOTE_CONNECTION_LOST:
					printf("Another client has lost the connection.\n");
					break;
				case ID_REMOTE_NEW_INCOMING_CONNECTION:
					printf("Another client has connected.\n");
					break;
				case ID_CONNECTION_REQUEST_ACCEPTED:
				{
					printf("Our connection request has been accepted.\n");
					// Prompt for player's name
					printf("Type your name: ");
					// Read their input and store it
					fgets(clientName, 512, stdin);
					// Gets the index of any new line or carriage return and removes it from the char array
					clientName[strcspn(clientName, "\r\n")] = 0;

					// Create data structure and initialize with our message identifier and message, in this case the user inputted client name
					messagePack pack(ID_GAME_MSG_PLAYER_CONNECTED, clientName);
					// Send the data structure to the server by casting it to a byte stream using const char* and passing the size of our data structure
					peer->Send((const char*)&pack, sizeof(pack), HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress, false);


				}
				break;
				case ID_NEW_INCOMING_CONNECTION:
					printf("A connection is incoming.\n");
					break;
				case ID_NO_FREE_INCOMING_CONNECTIONS:
					printf("The server is full.\n");
					break;
				case ID_DISCONNECTION_NOTIFICATION:
					if (isServer) {
						printf("A client has disconnected.\n");
					}
					else {
						printf("We have been disconnected.\n");
					}
					break;
				case ID_CONNECTION_LOST:
					if (isServer) {
						printf("A client lost the connection.\n");
					}
					else {
						printf("Connection lost.\n");
					}
					break;

					/* ------------------------------------------------------------------------------------------------------- */
					/*                                            CUSTOM MESSAGES                                              */
					/* ------------------------------------------------------------------------------------------------------- */

				case ID_GAME_MESSAGE_1:
				{
					RakNet::RakString rs;
					RakNet::BitStream bsIn(packet->data, packet->length, false);
					bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
					bsIn.Read(rs);
					printf("%s\n", rs.C_String());
				}
				break;

				// Custom message loop for player welcome
				case ID_GAME_MSG_PLAYER_CONNECTED:
				{
					// Cast packet to our data structure
					messagePack* p = (messagePack*)packet->data;

					// Create the client
					User client(p->msgText, packet->systemAddress.ToString());

					// Add the client to the user list
					users[currentUsers] = client;

					// increment current users
					currentUsers++;

					// Print the message with the message string from the structure
					printf("%s has joined the chat!\n", p->msgText);

				}
				break;

				// Custom message loop for player disconnect
				case ID_GAME_MSG_PLAYER_DISCONNECTED:
				{
					// Cast packet to our data structure
					messagePack* p = (messagePack*)packet->data;
					// Print the message with the message string from the structure
					printf("Goodbye, %s\n", p->msgText);
				}
				break;
				// DAN
				case ID_CHAT_MSG_REQUEST:
				{
					// cast packet to data
					ChatMessageRequest* p = (ChatMessageRequest*)packet->data;

					// Name to designate in the message delivery
					char senderName[512];
					// control if we broadcast
					bool isBroadcast = false;
					// read through user database
					for (int i = 0; i < currentUsers; i++)
					{
						// check the system address against the one in the packet
						if (users[i].systemAddress == packet->systemAddress.ToString())
						{
							// copy it on over
							strcpy(senderName, users[i].userName);
						}
					}

					// check if we broadcastin
					if (p->recieverUserName == "all")
						isBroadcast = true;

					// build message delivery data
					ChatMessageDelivery msgDelivery(ID_CHAT_MSG_DELIVERY, senderName, isBroadcast, p->msgTxt);
					peer->Send((const char*)&msgDelivery, sizeof(msgDelivery), HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress, isBroadcast);
				}
				break;
				// DAN
				case ID_CHAT_MSG_DELIVERY:
				{
					// cast packet to data
					ChatMessageDelivery* p = (ChatMessageDelivery*)packet->data;
					if (p->priv)
					{
						printf("(Private) %s : %s", p->senderUserName, p->msgTxt);
					}
					else
					{
						printf("%s : %s", p->senderUserName, p->msgTxt);
					}
				}
				break;

				case ID_CHAT_MSG_BROADCAST:
				{
					// Cast packet to our data structure
					messagePack* p = (messagePack*)packet->data;
					// Print the message with the message string from the structure
					printf(p->msgText);
				}
				break;

				default:
					printf("Message with identifier %i has arrived.\n", packet->data[0]);
					break;
				}
			}


			/* ------------------------------------------------------------------------------------------------------- */
			/*                                            USER INPUT COMMANDS AND MESSAGES                             */
			/* ------------------------------------------------------------------------------------------------------- */

			// DAN
			// get input	
			msg = "";
			printf("Input command: ");
			std::cin >> msg;

			// if command is being input; 47 = '/'
			if (msg.at(0) == '/')
			{
				// string to hold our command that we will split up
				std::string command;

				// gets string from after / to first space
				command = msg.substr(1, msg.find(' '));

				/* ------------------------------------------------------------------------------------------------------- */
				/*                                            SERVER ONLY COMMANDS                                         */
				/* ------------------------------------------------------------------------------------------------------- */

				// Prints out user name and IP of all connected users to host console, including host
				if (isServer && command == "users")
				{
					for (int i = 0; i < currentUsers; i++)
					{
						printf("User: %s | Address: %s\n", users[i].userName, users[i].systemAddress.c_str());
					}
				}

				/* ------------------------------------------------------------------------------------------------------- */
				/*                                            USER COMMANDS                                                */
				/* ------------------------------------------------------------------------------------------------------- */

				// Outputs all messaging/command types
				if (command == "help")
				{
					printf("Commands\n/disconnect - Disconnect from the server\n/msg all: - Broadcast message to all users\n/msg [name]: - Sends a private message to the specified user\n");
					if (isServer)
					{
						printf("\nAdmin Commands\n/ users - Display all usernames & IP\n");
					}

				}
				else if (command == "msg")
				{
					// string to hold the user name to send to
					std::string user, message;

					// gets string from space to : 
					user = msg.substr(msg.find(" "), msg.find(":"));

					message = msg.substr(msg.find(": ") + 1);

					// Create our private message request
					ChatMessageRequest messageRequest(ID_CHAT_MSG_REQUEST, user.c_str(), message.c_str());
					// Send to host
					peer->Send((const char*)&messageRequest, sizeof(messageRequest), HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress, false);
				}

				else if (command == "all")
				{
					// string to hold the user name to send to
					std::string  message;

					message = msg.substr(msg.find("all") + 1);

					// Create our private message request
					ChatMessageRequest messageRequest(ID_CHAT_MSG_REQUEST, "all", message.c_str());
					// Send to host
					peer->Send((const char*)&messageRequest, sizeof(messageRequest), HIGH_PRIORITY, RELIABLE_ORDERED, 0, (RakNet::AddressOrGUID)hostSystemAddress.c_str(), false);
				}
				else if (command == "disconnect")
				{
					// Prompt for disconnect message
					printf("Are you sure? Y/N: ");
					// Get input
					fgets(str, 512, stdin);
					// if yes,
					if ((str[0] == 'y') || (str[0] == 'Y'))
					{
						// Create data structure and initialize with our message identifier and message, in this case the user inputted client name
						messagePack pack(ID_GAME_MSG_PLAYER_DISCONNECTED, clientName);
						// Send the data structure to the server by casting it to a byte stream using const char* and passing the size of our data structure
						peer->Send((const char*)&pack, sizeof(pack), HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress, false);
						// Set to disconnect from server after loop is finished
						connected = false;
					}
				}
				else
				{
					printf("%s is an invalid command! Type /help to see list of all commands\n", command);
				}

			}

			// If set to disconnect, shutdown connection between server
			if(!connected)
				peer->Shutdown(50, 0, LOW_PRIORITY);
		}

	}

	// TODO - Add code body here
	printf("Disconnecting...\n");
	std::system("pause");
	 
	// Destroy peer on disconnect
	RakNet::RakPeerInterface::DestroyInstance(peer);

	return 0;
}