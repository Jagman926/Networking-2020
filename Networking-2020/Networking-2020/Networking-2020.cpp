#include <stdio.h>
#include <string.h>
#include <sstream>
#include <iostream>
#include "RakNet/RakPeerInterface.h"
#include "RakNet/MessageIdentifiers.h"
#include "Raknet/BitStream.h"
#include "Raknet/RakNetTypes.h"  // MessageID

// NOTES:
// Command Prompt > ipconfig > IPv4 (gets global IP of computer for server connection)
// peer->systemaddress in peer->send is how we specify a user to send data to 
// if broadcasting, its who NOT to send it to

/* MASTER TODO */
/*
	------- MESSAGE STRUCTURE -------
	- User information heading each message
	- Can send and receive public messages (broadcast to all via host) or private messages (to/from a specific participant)

	------- ADMIN STRUCTURE -------
    - Maintains user names and IP addresses of multiple connected users
	- Relays and redirects all messages and events from all participants
	- Broadcast messages to all or selected clients, public or private
	- Displays all inbound and outbound messages, public or private, with the sender and receiver user names
	- On demand, print user names and IP addresses of all connected users to the host console

	------- MESSAGE TYPES -------
	- Chat message request (See type below for tasks)
	- Chat message delivery (See type below for tasks)

	------- USER INTERFACE -------
	- Console clearly displays keyboard commands or shortcuts for user
	- Console should refresh as needed
	- Chat messages should always display the respective sender’s user name
		- If the message was intended for a single user, only they should see it 
		and have some indicator that they are the only one seeing the message, 
		the host being the exception (they can see all messages, public or private)
	- Chat messages should not be re-delivered to the sender
*/

enum GameMessages
{
	ID_GAME_MESSAGE_1 = ID_USER_PACKET_ENUM + 1,
	// Custom message identifier for welcoming the player
	ID_GAME_MSG_PLAYER_CONNECTED,
	ID_GAME_MSG_PLAYER_DISCONNECTED,
	ID_CHAT_MSG_BROADCAST,
	ID_CHAT_MSG_REQUEST,
	ID_CHAT_MSG_DELIVERY
};

// Contains information for specific clients
struct User
{
public:
	/* VARIABLES */

	// Name of the user that is printed
	char userName[512];
	// User's IP
	char localIP[512];
	
	/* FUNCTIONS */

	// Default ctor
	User() {};
	// Used for creating new users
	User(char name[], char ip[]) { strcpy(userName, name), strcpy(localIP, ip); };

};

// Custom message packet structure
// Force compiler to pack the structure as byte-aligned.
#pragma pack (push, 1)
struct messagePack
{
public: 
	/* VARIABLES */

	RakNet::MessageID msgID;
	// Should use pre allocated byte array memory instead of string
	std::string msgString;

	/* FUNCTIONS */

	messagePack(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };
	void CreatePacket(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };

};
#pragma pack (pop)

/*
TODO: Chat message request: Generated by participant, a request for host to send out a message. Should have the following fields (at minimum):
	- Receiver user name: The name of the chat room participant who should receive the message
		- if the message is public (broadcast), use some recognizable keyword or symbol
		- Messaging the host is also allowed; self-messaging is not allowed
	- Message text: The contents of the message.  Should have a maximum length
*/

#pragma pack (push, 1)
struct ChatMessageRequest
{
public:
	// The name of the chat room participant who should receive the message
	char recieverUserName[512];
	// The contents of the message.  Should have a maximum length.
	char msgTxt[512];

	// Functions
	// ChatMessageRequest(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };
	// void CreatePacket(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };

};
#pragma pack (pop)

/*
TODO: Chat message delivery: Generated by host, an actual message being delivered. Should have the following fields (at minimum):
	- Sender user name: The name of the participant from whom the message originated
		- Since this could include the host, they should be a recognizable name
	- Public or private: Indicates whether the message was broadcast or directed at the receiver
	- Message text: The contents of the message.  Should have a maximum length (same as above)
*/

#pragma pack (push, 1)
struct ChatMessageDelivery
{
public:
	
	// The name of the participant from whom the message originated; since this could include the host, they should be a recognizable name.
	char senderUserName[1024];
	// Indicates whether the message was broadcast or directed at the receiver.
	bool priv;
	// The contents of the message.  Should have a maximum length.
	char msgTxt[1024];

	// Functions
	//ChatMessageDelivery(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };
	//void CreatePacket(RakNet::MessageID ID, std::string string) { msgID = ID, msgString = string; };

};
#pragma pack (pop)

/* VARIABLES */
/* ------------------------------------------------------------------- */

// default max clients
const unsigned int DEFAULT_MAX_CLIENTS = 10;

// number of maximum clients
unsigned int maxClients = DEFAULT_MAX_CLIENTS;

// number of current users, including host
int currentUsers = 0;

// the server port number
unsigned short serverPort;

// List containing all users 
User users[DEFAULT_MAX_CLIENTS];


/* ------------------------------------------------------------------- */

int main(void)
{
	// default input string
	char str[1024];

	// Name of the client 
	char clientName[1024];

	// peer instance
	RakNet::RakPeerInterface* peer = RakNet::RakPeerInterface::GetInstance();

	// server booleon
	bool isServer = false;

	// Create our packet variable
	RakNet::Packet *packet;

	// Connected to chat
	bool connected = false;
	
	// While loop to maintain user in application
	while (1)
	{
		if (!connected)
		{
			// TO-DO: Create exit prompt to close the application
			printf("Welcome to the chat room!\n");
			printf("You are currently in the lobby state.\n");
			printf("Would you like to Join (J) or Host (H) a chat room? (D) to Disconnect \n");
			fgets(str, 512, stdin);

			if ((str[0] == 'j') || (str[0] == 'J'))
			{
				RakNet::SocketDescriptor sd;
				peer->Startup(1, &sd, 1);
				isServer = false;

				//// Prompt for server port input
				//printf("Enter server port number\n");
				//// Read user input
				//fgets(str, 512, stdin);
				//// Set server port to inputed value in str
				//serverPort = strtol(str, NULL, 0);

				// fixed server port
				serverPort = 1;

				// Connected
				connected = true;
			}
			else if ((str[0] == 'h') || (str[0] == 'H')){

				//// Prompt for client number input; only when using a server
				//printf("Enter maximum client number\n");
				//// Read user input
				//fgets(str, 512, stdin);
				//// Set max clients to inputed value in str
				//maxClients = strtol(str, NULL, 0);

				// fixed server port
				serverPort = 1;

				RakNet::SocketDescriptor sd(serverPort, 0);
				peer->Startup(maxClients, &sd, 1);
				isServer = true;

				// create the server's name which will always be the same so its recognizable
				char adminName [512] = "Admin";
				
				// Create the User representing the server
				User server(adminName, (char*)peer->GetLocalIP(0));

				// Add the server to the user list
				users[currentUsers] = server;

				// increment current users now that we have one
				currentUsers++;

				// Connected
				connected = true;
			}
			else {
				// Disconnect
				connected = false;
			}

			if (isServer)
			{
				printf("Starting the server!!!\n");

				std::cout << "Your IP is: " << peer->GetLocalIP(0) << "\n";

				std::cout << "Your GUID is: " << peer->GetMyGUID().ToString() << "\n";

				// We need to let the server accept incoming connections from the clients
				peer->SetMaximumIncomingConnections(maxClients);
			}
			else
			{
				printf("Enter server IP or hit enter for 127.0.0.1\n");
				fgets(str, 512, stdin);

				// Changed == to 10 since fgets prints enter as 10 instead of 0
				if (str[0] == 10) {
					strcpy(str, "127.0.0.1");
				}
				printf("Starting the client.\n");

				std::cout << "Your IP is: " << peer->GetLocalIP(0) << "\n";

				std::cout << "Your GUID is: " << peer->GetMyGUID().ToString() << "\n";

				peer->Connect(str, serverPort, 0, 0);
			}
		}
		else
		{
			for (packet = peer->Receive(); packet; peer->DeallocatePacket(packet), packet = peer->Receive())
			{
				switch (packet->data[0])
				{
				/* ------------------------------------------------------------------------------------------------------- */
				/*                                            DEFAULT MESSAGES                                             */
				/* ------------------------------------------------------------------------------------------------------- */

				case ID_REMOTE_DISCONNECTION_NOTIFICATION:
					printf("Another client has disconnected.\n");
					break;
				case ID_REMOTE_CONNECTION_LOST:
					printf("Another client has lost the connection.\n");
					break;
				case ID_REMOTE_NEW_INCOMING_CONNECTION:
					printf("Another client has connected.\n");
					break;
				case ID_CONNECTION_REQUEST_ACCEPTED:
				{
					printf("Our connection request has been accepted.\n");

					// Prompt for player's name
					printf("Type your name: ");
					// Read their input and store it
					fgets(clientName, 512, stdin);

					// Create data structure and initialize with our message identifier and message, in this case the user inputted client name
					messagePack pack(ID_GAME_MSG_PLAYER_CONNECTED, clientName);
					// Send the data structure to the server by casting it to a byte stream using const char* and passing the size of our data structure
					peer->Send((const char*)&pack, sizeof(pack), HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress, false);

					// Prompt for disconnect message
					printf("Disconnect? Y/N: ");
					// Get input
					fgets(str, 512, stdin);
					// if yes,
					if ((str[0] == 'y') || (str[0] == 'Y'))
					{
						// Create data structure and initialize with our message identifier and message, in this case the user inputted client name
						messagePack pack(ID_GAME_MSG_PLAYER_DISCONNECTED, clientName);
						// Send the data structure to the server by casting it to a byte stream using const char* and passing the size of our data structure
						peer->Send((const char*)&pack, sizeof(pack), HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress, false);
						// Set to disconnect from server after loop is finished
						connected = false;
					}
				}
				break;
				case ID_NEW_INCOMING_CONNECTION:
					printf("A connection is incoming.\n");
					break;
				case ID_NO_FREE_INCOMING_CONNECTIONS:
					printf("The server is full.\n");
					break;
				case ID_DISCONNECTION_NOTIFICATION:
					if (isServer) {
						printf("A client has disconnected.\n");
					}
					else {
						printf("We have been disconnected.\n");
					}
					break;
				case ID_CONNECTION_LOST:
					if (isServer) {
						printf("A client lost the connection.\n");
					}
					else {
						printf("Connection lost.\n");
					}
					break;

				/* ------------------------------------------------------------------------------------------------------- */
				/*                                            CUSTOM MESSAGES                                              */
				/* ------------------------------------------------------------------------------------------------------- */

				case ID_GAME_MESSAGE_1:
				{
					RakNet::RakString rs;
					RakNet::BitStream bsIn(packet->data, packet->length, false);
					bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
					bsIn.Read(rs);
					printf("%s\n", rs.C_String());
				}
				break;

				// Custom message loop for player welcome
				case ID_GAME_MSG_PLAYER_CONNECTED:
				{

					// Cast packet to our data structure
					messagePack* p = (messagePack*)packet->data;
					
					//char address[512];
					//strcpy(address, packet->systemAddress.GetIPVersion);
					//// Create the client
					//User client(p->msgString.c_str, );
					//
					//
					//// Add the client to the user list
					//users[currentUsers] = client;
					//
					//// increment current users
					//currentUsers++;

					// Print the message with the message string from the structure
					// TODO: Format to fix newline after name
					printf(p->msgString.c_str());
					printf(" has joined the chat!");
					printf("\n");
					printf("Current Users: ");

					for (int i = 0; i < currentUsers; i++)
					{
						printf(users[i].userName);
						printf(users[i].localIP);
						printf("\n");

					}
	
					//TODO - Fix string stream
					// Broadcast to other clients a user has connected to 
					std::string broadcastMsg;
					
					broadcastMsg = packet->guid.ToString();
					
					messagePack pack(ID_CHAT_MSG_BROADCAST, broadcastMsg.c_str());
					peer->Send((const char*)& pack, sizeof(pack), HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress, true);
				}
				break;

				// Custom message loop for player disconnect
				case ID_GAME_MSG_PLAYER_DISCONNECTED:
				{
					// Cast packet to our data structure
					messagePack* p = (messagePack*)packet->data;
					// Print the message with the message string from the structure
					printf("Goodbye, %s\n", p->msgString.c_str());
				}
				break;

				case ID_CHAT_MSG_BROADCAST:
				{
					// Cast packet to our data structure
					messagePack* p = (messagePack*)packet->data;
					// Print the message with the message string from the structure
					printf( p->msgString.c_str());
				}
				break;

				default:
					printf("Message with identifier %i has arrived.\n", packet->data[0]);
					break;
				}
			}

			// If set to disconnect, shutdown connection between server
			if(!connected)
				peer->Shutdown(50, 0, LOW_PRIORITY);
		}

	}

	// TODO - Add code body here

	// Destroy peer on disconnect
	RakNet::RakPeerInterface::DestroyInstance(peer);

	return 0;
}